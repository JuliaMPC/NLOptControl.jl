<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General · NLOptControl.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NLOptControl.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/Brachistochrone/main.html">Quick Ex#1: Brachistochrone</a></li><li><a class="toctext" href="../tutorials/MoonLander/main.html">Quick Ex#2: Moon Lander</a></li><li><a class="toctext" href="../tutorials/BrysonDenham/main.html">Bryson Denham</a></li><li><a class="toctext" href="../tutorials/Beam/main.html">Beam Problem</a></li><li><a class="toctext" href="../tutorials/HyperSensitive/main.html">HyperSensitive</a></li><li><a class="toctext" href="../tutorials/RobotArm/main.html">RobotArm</a></li><li><a class="toctext" href="../tutorials/Rocket/main.html">Rocket</a></li><li><a class="toctext" href="../tutorials/Unicycle/main.html">Unicycle Model</a></li></ul></li><li><span class="toctext">MPC</span><ul><li class="current"><a class="toctext" href="index.html">General</a><ul class="internal"><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Settings-1">Settings</a></li><li><a class="toctext" href="#Flags-1">Flags</a></li><li class="toplevel"><a class="toctext" href="#simulationModes-1">simulationModes</a></li><li><a class="toctext" href="#OCP-(:OCP)-1">OCP (<code>:OCP</code>)</a></li><li><a class="toctext" href="#IP-(:IP)-1">IP (<code>:IP</code>)</a></li><li><a class="toctext" href="#InternalEP-(:IPEP)-1">InternalEP (<code>:IPEP</code>)</a></li><li><a class="toctext" href="#EP-(:EP)-1">EP (<code>:EP</code>)</a></li><li class="toplevel"><a class="toctext" href="#Synchronization-1">Synchronization</a></li><li><a class="toctext" href="#Fixed-Execution-Horizon-1">Fixed Execution Horizon</a></li><li><a class="toctext" href="#Variable-Execution-Horizon-1">Variable Execution Horizon</a></li><li class="toplevel"><a class="toctext" href="#Error-1">Error</a></li><li><a class="toctext" href="#OCP-1">OCP</a></li><li><a class="toctext" href="#IP-1">IP</a></li><li><a class="toctext" href="#EP-1">EP</a></li><li class="toplevel"><a class="toctext" href="#InternalEP-1">InternalEP</a></li><li class="toplevel"><a class="toctext" href="#Results-and-Variables-1">Results and Variables</a></li><li><a class="toctext" href="#OCP-2">OCP</a></li><li><a class="toctext" href="#IP-2">IP</a></li><li class="toplevel"><a class="toctext" href="#need-a-mapping-between-states-and-controls-for-different-models-to-calculate-error-1">need a mapping between states and controls for different models to calculate error</a></li><li><a class="toctext" href="#EP-2">EP</a></li><li><a class="toctext" href="#Error-2">Error</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>MPC</li><li><a href="index.html">General</a></li></ul><a class="edit-page" href="https://github.com/JuliaMPC/NLOptControl.jl/blob/master/docs/src/mpc/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>General</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="General-1" href="#General-1">General</a></h1><p>NOTE: the following documentation needs to be updated.</p><p>The following link provides documentation all of the MPC specific functionality for NLOptControl.jl.</p><p>The basic MPC problem is first defined using the  <code>defineMPC!()</code> function.</p><p>In this function call, the user needs to specify all of the data that will eventually be needed to call the <code>configureMPC!()</code>. So, depending on the <code>:simulationMode</code> different sets of initialization data must be first be passed to <code>defineMPC!()</code>. These sets of initialization data are described for each <code>:simulationMode</code> in simulationModes.  </p><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.mpc.t</code></td><td>current time in (s)</td></tr><tr><td><code>n.mpc.tex</code></td><td>current execution time horizon in (s)</td></tr><tr><td><code>n.mpc.tp</code></td><td>current prediction time in (s) == <code>getvalue(n.tf)</code> if <code>n.s.finalTimeDV==false</code> (otherwise it is not applicable)</td></tr><tr><td><code>n.mpc.maxSim</code></td><td>maximum number of total MPC updates</td></tr></table><h2><a class="nav-anchor" id="Settings-1" href="#Settings-1">Settings</a></h2><p>The settings are defined using the <code>configureMPC!()</code> function where the following keys can be passed.</p><table><tr><th>Variable</th><th>Key</th><th>Possible Values</th><th>Description</th></tr><tr><td><code>n.mpc.s.mode</code></td><td><code>:mode</code></td><td><code>:OCP</code>,  <code>:IP</code>, <code>:IPEP</code>, <code>:EP</code></td><td>identifies the  <code>simulationMode</code></td></tr><tr><td><code>n.mpc.s.predictX0</code></td><td><code>:predictX0</code></td><td><code>true</code> or <code>false</code></td><td>bool to indicate if <code>X0</code> will be predicted</td></tr><tr><td><code>n.mpc.s.fixedTex</code></td><td><code>:fixedTex</code></td><td><code>true</code> or <code>false</code></td><td>bool to indicate if <code>n.mpc.tex</code> is fixed</td></tr><tr><td><code>n.mpc.s.IPKnown</code></td><td><code>:IPKnown</code></td><td><code>true</code> or <code>false</code></td><td>bool to indicate if the <code>IP</code> is known</td></tr><tr><td><code>n.mpc.s.saveMode</code></td><td><code>:saveMode</code></td><td><code>:all</code> or <code>:none</code></td><td>indicates the mode that is to be utilized to save the results</td></tr></table><p>As an example:</p><pre><code class="language-julia">configureMPC!(n,(:mode=&gt;:OCP))</code></pre><h2><a class="nav-anchor" id="Flags-1" href="#Flags-1">Flags</a></h2><p>The value for all of the flags is <code>true</code> or <code>false</code>.</p><table><tr><th>Variable</th><th>Initial Value</th><th>Description</th></tr><tr><td><code>n.mpc.flags.goalReached</code></td><td><code>false</code></td><td>bool to indicate if the goal has been reached</td></tr></table><h1><a class="nav-anchor" id="simulationModes-1" href="#simulationModes-1">simulationModes</a></h1><p>There are four different possible values for <code>simulationMode</code> that can be set by the <code>:mode</code> key as described above.</p><h2><a class="nav-anchor" id="OCP-(:OCP)-1" href="#OCP-(:OCP)-1">OCP (<code>:OCP</code>)</a></h2><p>In this case, the plant model is the set of differential equations defined within the OCP. The entire OCP is still defined entirely outside of the MPC_Module. For instance, <code>n.numStates</code> and <code>n.numControls</code> represent the number of states and controls for the OCP, respectively.</p><p>To keep track of all of the <code>n.X0</code>s that are passed to the OCP, we define an time stamped array is defined called <code>n.mpc.X0ocp</code>. The first element in <code>n.mpc.X0ocp</code> is automatically set to <code>n.X0</code> after calling <code>defineMPC!()</code>.</p><hr/><p><strong>NOTE</strong></p><p>For all modes, the initial state in optimization, <code>n.X0</code>, is set using the <code>define()</code> function. If needed, it can be changed before the initial optimization using the <code>updateX0!()</code> function.</p><hr/><p><code>n.mpc.X0ocp</code> and <code>n.U</code> are passed to these differential equations to simulate the plant for a time given by <code>n.mpc.tex</code>, the final state is stored in the next element in the <code>n.mpc.X0ocp</code> array. Then, <code>n.X0</code> is updated to <code>n.mpc.X0ocp[end]</code>.</p><hr/><p><strong>NOTE</strong></p><p>Since the plant is known in this case, <code>n.X0</code> is updated using future knowledge of the state. So, the simulation is &quot;cheating&quot; in a way, by assuming perfect knowledge of where the vehicle will be after <code>n.mpc.tex</code>.</p><pre><code class="language-none">                           Given
                             |
                             V
        OCP solving    n.mpc.X0ocp[end]
      --------------&gt;
      x----------------------x----------------------x
  n.mpc.t0         (n.mpc.t0 + n.mpc.tex)</code></pre><hr/><h2><a class="nav-anchor" id="IP-(:IP)-1" href="#IP-(:IP)-1">IP (<code>:IP</code>)</a></h2><p>In this case, the OCP is solved controls are sent to</p><h3><a class="nav-anchor" id="Variables-2" href="#Variables-2">Variables</a></h3><p>The states and controls in this model may not be the same as they are in the <code>OCP</code> and thus <code>n.ocp.state.num</code> and <code>n.ocp.control.num</code> may not represent the number of states and controls, respectively for the <code>IP</code>.</p><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.mpc.ip.control.num</code></td><td>number of control variables for the <code>IP</code></td></tr><tr><td><code>n.mpc.ip.state.num</code></td><td>number of state variables for the <code>IP</code></td></tr><tr><td><code>n.mpc.IPeMap</code></td><td>mapping</td></tr></table><p>As an example, assume that in the OCP, the <a href="https://github.com/JuliaMPC/VehicleModels.jl/blob/master/src/KinematicBicycle/KinematicBicycle.jl">KinematicBicycle</a> is used. The state and controls should be defined as:</p><pre><code class="language-julia">states!(n,[:x,:y,:psi,:ux])
controls!(n,[:sa,:ax])</code></pre><p>Then assume that the <a href="https://github.com/JuliaMPC/VehicleModels.jl/blob/master/src/Three_DOF/Three_DOF.jl">ThreeDOFv1</a> is used for the <code>IP</code>. The states and controls would be defined as:</p><pre><code class="language-none">statesIP!(n,[:x,:y,:v,:r,:psi,:sa,:ux,:ax])
controlsIP!(n,[:sr,:jx])</code></pre><p>To calculate the error array, each state variable in the <code>OCP</code> is compared with each state and control variable in the <code>IP</code>. The result is stored in a map called <code>n.mpc.mIP</code>. For the aforementioned example, that map look like:</p><pre><code class="language-julia"></code></pre><h3><a class="nav-anchor" id="State-Equations-1" href="#State-Equations-1">State Equations</a></h3><p>For this mode, the plant model is defined by <code>plantEquations</code> within NLOptControl.</p><p>This is simply done as</p><pre><code class="language-julia"> n.mpc.plantEquations = KinematicBicycle</code></pre><p>where <code>KinematicBicycle</code> is a function that solves a set of ODEs given a control, an initial state, and a simulation time. For an example see <a href="https://github.com/JuliaMPC/VehicleModels.jl/blob/master/src/KinematicBicycle/KinematicBicycle.jl#L24">VehicleModels.jl</a>.</p><h2><a class="nav-anchor" id="InternalEP-(:IPEP)-1" href="#InternalEP-(:IPEP)-1">InternalEP (<code>:IPEP</code>)</a></h2><p>In this mode, there is an <code>IP</code> that can be used to help predict X0 (X0p) for an <code>EP</code>.</p><p>This option can be useful when the OCP needs to be solved quickly and a more complicated model (<code>IP</code>) may give better <code>X0p</code>. Also, in developing functionality to determine the error in <code>X0p</code>. That is without having to deal with an external simulation can methods be developed to improve <code>X0p</code>.</p><h2><a class="nav-anchor" id="EP-(:EP)-1" href="#EP-(:EP)-1">EP (<code>:EP</code>)</a></h2><p>A set of <code>n.X</code> and <code>n.U</code> makes up <code>UEX</code> and is fed directly to an <code>EP</code>.</p><h1><a class="nav-anchor" id="Synchronization-1" href="#Synchronization-1">Synchronization</a></h1><p>Synchronizing MPC systems is critical for performance and safety.</p><h2><a class="nav-anchor" id="Fixed-Execution-Horizon-1" href="#Fixed-Execution-Horizon-1">Fixed Execution Horizon</a></h2><h2><a class="nav-anchor" id="Variable-Execution-Horizon-1" href="#Variable-Execution-Horizon-1">Variable Execution Horizon</a></h2><p>Currently, there is no functionality for this. But, this may be useful and it would augment a prediction of the time as well as <code>X0</code>. So, to account for this possible expansion, a predicted time (very simply the current time plus <code>n.mpc.tex</code> for the fixed execution horizon case) is added to <code>X0p</code>.</p><p>This is the case, where the OCP is being solved as quickly as possible. In this case predicting <code>n.r.ocp.tSolve</code>( roughly equal to <code>n.mpc.v.tex</code>) is a challenging problem because there is no guarantee that the OCP will be solved in a particular amount of time. A simple way to predict <code>n.r.ocp.tSolve</code> is to average several of the previous <code>n.r.ocp.tSolve</code> values.  </p><h1><a class="nav-anchor" id="Error-1" href="#Error-1">Error</a></h1><p>Evaluating the error of the prediction of <code>X0</code> is important. Additionally, evaluating the tracking error (or following error) for each state is also important. Fortunately, there is built in functionality to calculate and save these errors.  </p><h2><a class="nav-anchor" id="OCP-1" href="#OCP-1">OCP</a></h2><p>Currently there is no need to quantify error in this case.</p><h2><a class="nav-anchor" id="IP-1" href="#IP-1">IP</a></h2><p>In this case, the errors are calculated</p><h2><a class="nav-anchor" id="EP-1" href="#EP-1">EP</a></h2><h1><a class="nav-anchor" id="InternalEP-1" href="#InternalEP-1">InternalEP</a></h1><p>This is the most complicated mode and there can be errors</p><h1><a class="nav-anchor" id="Results-and-Variables-1" href="#Results-and-Variables-1">Results and Variables</a></h1><p>The following tables describe the results and are organized by mode.</p><p>Concern is that there may be too much data to save.</p><h2><a class="nav-anchor" id="OCP-2" href="#OCP-2">OCP</a></h2><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.X0</code></td><td>current initial state</td></tr><tr><td><code>n.r.X</code></td><td>current solution for states</td></tr><tr><td><code>n.r.U</code></td><td>current solution for controls</td></tr><tr><td><code>n.r.t_st</code></td><td>corresponding time for states (and controls minus the last entry)</td></tr><tr><td><code>n.mpc.r.dfsX0</code></td><td>DataFrame of all <code>n.X0</code> arrays used in optimization each appended with <code>n.mpc.t</code></td></tr></table><h2><a class="nav-anchor" id="IP-2" href="#IP-2">IP</a></h2><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.mpc.r.UIP</code></td><td>array of latest matrix of controls for the <code>IP</code></td></tr><tr><td><code>n.mpc.r.dfsUIP</code></td><td>DataFrame of all matrices of <code>n.mpc.r.UIP</code></td></tr><tr><td><code>n.mpc.r.X0pIP</code></td><td>array of latest prediction of <code>n.mpc.r.X0aIP</code></td></tr><tr><td><code>n.mpc.r.dfsX0pIP</code></td><td>DataFrame of all <code>n.mpc.r.X0pIP</code> arrays</td></tr><tr><td><code>n.mpc.r.X0aIP</code></td><td>array of latest actual initial state for the <code>IP</code></td></tr><tr><td><code>n.mpc.r.dfsX0aIP</code></td><td>DataFrame of all <code>n.mpc.r.X0aIP</code> arrays</td></tr><tr><td><code>n.mpc.r.X0pIPe</code></td><td>array of latest error in between <code>n.mpc.r.X0pIP</code> and <code>n.mpc.r.X0aIP</code></td></tr><tr><td><code>n.mpc.r.dfsX0pIPe</code></td><td>DataFrame of all <code>n.mpc.r.X0pIPe</code> arrays</td></tr></table><h1><a class="nav-anchor" id="need-a-mapping-between-states-and-controls-for-different-models-to-calculate-error-1" href="#need-a-mapping-between-states-and-controls-for-different-models-to-calculate-error-1">need a mapping between states and controls for different models to calculate error</a></h1><h2><a class="nav-anchor" id="EP-2" href="#EP-2">EP</a></h2><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.mpc.r.UIP</code></td><td>latest matrix of controls for the <code>IP</code></td></tr><tr><td><code>n.mpc.r.dfsUIP</code></td><td>DataFrame of all matrices of <code>n.mpc.r.UIP</code></td></tr></table><h2><a class="nav-anchor" id="Error-2" href="#Error-2">Error</a></h2><table><tr><th>Variable</th><th>Description</th></tr><tr><td><code>n.mpc.r.X0IPE</code></td><td></td></tr><tr><td><code>n.mpc.r.dfsX0IPE</code></td><td>DataFrame</td></tr></table><footer><hr/><a class="previous" href="../tutorials/Unicycle/main.html"><span class="direction">Previous</span><span class="title">Unicycle Model</span></a></footer></article></body></html>
